<!--
    @license
    Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
    This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
    The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
    The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
    Code distributed by Google as part of the polymer project is also
    subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="google-cast-sender-api.html">

<!--
<p> The `google-castable-video` element enables your HTML5 videos to be casted to any Chromecast. <br>
Behaves exactly like a HTML5 video element except for some added methods and events. </p>
<p> Instead of listening for timeupdate please listen for the `google-castable-video-timeupdate` event which is fired no matter if the video is playing locally or on a Chromecast device. </p>

##### Example
<code>
  <video is="google-castable-video">
    <source src="http://commondatastorage.googleapis.com/gtv-videos-bucket/big_buck_bunny_1080p.mp4" type="video/mp4">
  </video>
</code>  

@element google-castable-video
@blurb A Polymer element for extending HTML5 video to make it Chromecast enabled.
@status alpha
@homepage https://github.com/GoogleWebComponents/google-castable-video
-->
<!-- TODO(tschaeff):
- ratechange to change playbackspeed (if even possible)
-->
<polymer-element name="google-castable-video" extends="video">

 <script>

    Polymer({
      /**
       * The mode state depending on whether the video is playing locally or on the cast device.
       * 
       * @property casting
       * @type bool
       * @default false
       */
      casting: false,

      /**
       * Returns if any Chromecast is available.
       * 
       * @property receiverAvailable
       * @type bool
       * @default false
       */
      receiverAvailable: false,

      /**
       * The real paused state for local and cast playback.
       * 
       * @property globalPaused
       * @type bool
       * @default true
       */
      globalPaused: true,

      /**
       * The chrome.cast.Media object.
       * 
       * @property castMedia
       * @type Object
       * @default false
       */
      castMedia: null,

      /**
       * The chrome.cast.Session object.
       * 
       * @property session
       * @type Object
       * @default false
       */
      session: null,

      ready: function() {
        //initialize cast api
        window['__onGCastApiAvailable'] = function(loaded, errorInfo) {
          if (loaded) {
            this.initializeCastApi();
          } else {
            this.triggerError("INITIALIZE_ERROR");
          }
        }.bind(this);

        //seeked event listener
        this.addEventListener("seeked", function(){
          if(this.casting){
            var req = new chrome.cast.media.SeekRequest();
            req.currentTime = this.currentTime;
            this.castMedia.seek(req);
          }
        });

        //volume change event listener
        this.addEventListener("volumechange", function(){
          if(this.casting){
            this.castMedia.setVolume(new chrome.cast.media.VolumeRequest(new chrome.cast.Volume(this.volume, this.muted)));
          }
        });

        //redirect timeupdate event
        this.addEventListener("timeupdate", function(){
          this.triggerTimeupdate(this.currentTime);
          this.globalPaused = this.paused;
        });
      },

      //Called internally when cast sender api has loaded.
      initializeCastApi: function() {
        var applicationID = chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID;
        var sessionRequest = new chrome.cast.SessionRequest(applicationID);
        var apiConfig = new chrome.cast.ApiConfig(sessionRequest,
          function(e){
            //sessionListener
            this.triggerCasting(true);
            this.session = e;
            if (this.session.media.length != 0) {
              this.onMediaDiscovered.call(this, 'onRequestSessionSuccess', this.session.media[0]);
            }
            //session update listener
            this.session.addUpdateListener(this.sessionUpdateListener.bind(this));
            //cast timeupdate
            this.timeupdateInterval = setInterval(function(){
              if(this.castMedia && this.castMedia.playerState === "PLAYING"){
                this.triggerTimeupdate(this.castMedia.getEstimatedTime());
                this.globalPaused = false;
              } else {
                this.globalPaused = true;
              }
            }.bind(this),250);
            //start playing on cast if playing locally
            if(!this.paused){
              this.play();
              this.pause(false);
            }
          }.bind(this),
          function(e){
            //receiverListener
            if( e === chrome.cast.ReceiverAvailability.AVAILABLE) {
              //available -> show chromecast icon
              this.triggerAvailability(true);
            }
            else {
              this.triggerAvailability(false);
            }
          }.bind(this));
        chrome.cast.initialize(apiConfig, function(){
          //onInitSuccess
          this.fire('google-castable-video-initialized');
        }.bind(this), function(){
          this.triggerError("INITIALIZE_ERROR");
        });
      },

      /**
      * Call this when the user clicks the cast icon. Opens the cast extension to create a session with the selected receiver.
      *
      * @method launchSessionManager
      */
      launchSessionManager: function(){
        //create session
        chrome.cast.requestSession(function(e){
          //onRequestSessionSuccess //connected to cast -> launchMedia
          this.triggerCasting(true);
          this.session = e;
          this.session.addUpdateListener(this.sessionUpdateListener.bind(this));
          //if video is playing start playing on chromecast at same position
          if(!this.paused){
            this.play();
            this.pause(false);
          }
          //cast timeupdate
          this.timeupdateInterval = setInterval(function(){
            if(this.castMedia && this.castMedia.playerState === "PLAYING"){
              this.triggerTimeupdate(this.castMedia.getEstimatedTime());
              this.globalPaused = false;
            } else {
              this.globalPaused = true;
            }
          }.bind(this),250);
        }.bind(this));
      },

      //internal method //called when cast session status changes
      sessionUpdateListener: function(isAlive){
        if(!isAlive){
          this.triggerCasting(false);
          this.synchronizeMedia(true);
          //if video was playing in cast start playing locally
          if(this.castMedia.playerState === "PLAYING"){
            this.play();
          }
          this.castMedia = null;
          this.session = null;
          //remove timeupdate interval
          clearInterval(this.timeupdateInterval);
        }
      },

      //internal method //called when media was set through launchsession or was already playing on cast device
      onMediaDiscovered: function(how, media) {
        this.castMedia = media;
        if(how==="loadMedia"){
          this.synchronizeMedia(false);
        }
      },

      //internal method
      synchronizeMedia: function(castMaster){
        if(castMaster){
          var position = this.castMedia.getEstimatedTime();
          this.currentTime = position;
        } else {
          var position = this.currentTime;
          var req = new chrome.cast.media.SeekRequest();
          req.currentTime = position;
          this.castMedia.seek(req);
        }
      },

      /**
       * Call the `play` method from your controls.
       *
       * @method play
       */
      play: function(cast){
        if((cast != undefined && !cast) || (!cast && !this.casting)){
          this.super();
        } else {
          //handle cast stuff
          if(!this.castMedia){
            var mediaInfo = new chrome.cast.media.MediaInfo(this.currentSrc);
            //IMPORTANT set content type! //TODO get current type from currentsrc
            mediaInfo.contentType = "video/mp4";
            var request = new chrome.cast.media.LoadRequest(mediaInfo);
            this.session.loadMedia(request,
              this.onMediaDiscovered.bind(this, 'loadMedia'),
              function(e){
                //onMediaError
                this.triggerError("LOAD_MEDIA_ERROR");
              }.bind(this)
            );
          } else {
            this.castMedia.play();
          }
        }
      },

      /**
       * Call the `pause` method from your controls.
       *
       * @method pause
       */
      pause: function(cast){
        if((cast != undefined && !cast) || (!cast && !this.casting)){
          this.super();
        } else {
          this.castMedia.pause();
        }
      },

      /**
       * The `google-castable-video-timeupdate` event is fired whenever 
       * the video's playback position changes.
       *
       * @event google-castable-video-timeupdate
       * @param {Object} detail
       *   @param {number} detail.currentTime The current video position.
       */
       triggerTimeupdate: function(position) {
        this.fire('google-castable-video-timeupdate', {
          "currentTime": position
        });
      },

      /**
       * The `google-castable-video-error` event is fired whenever 
       * an error occurs.
       *
       * @event google-castable-video-error
       * @param {Object} detail
       *   @param {string} detail.error The error type.
       */
      triggerError: function(description) {
        this.fire('google-castable-video-error', {
          "error": description
        });
      },

      /**
       * The `google-castable-video-receiver-status` event is fired whenever 
       * the availability of Chromecasts changes. Use this to show or hide the cast icon.
       *
       * @event google-castable-video-receiver-status
       * @param {Object} detail
       *   @param {bool} detail.available Shows if receivers are available.
       */
      triggerAvailability: function(availability) {
        this.receiverAvailable = availability;
        this.fire('google-castable-video-receiver-status', {
          "available": availability
        });
      },

      /**
       * The `google-castable-video-casting` event is fired whenever the
       * connection status to a Chromecast changes. Use this to change the cast icon.
       *
       * @event google-castable-video-casting
       * @param {Object} detail
       *   @param {bool} detail.casting True if connected.
       */
       triggerCasting: function(casting) {
        this.casting = casting;
        this.fire('google-castable-video-casting', {
          "casting": casting
        });
      }

    });

  </script>

</polymer-element>
